{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FileNameFlow: A Filename-Driven Pipeline Framework","text":"<p>FileNameFlow is a lightweight framework designed for data processing pipelines that rely on filenames with wildcard support.</p> <p>At its core, FileNameFlow emphasizes self-descriptive filenames, driving task execution based on these patterns. This approach simplifies data processing.</p> <p>FileNameFlow seamlessly integrates with distributed frameworks like Dask, expanding resource management capabilities to accommodate Concurrency, PBS, SLURM, and other distributed computation systems.</p>"},{"location":"#concept-1-filename-selection-patterns","title":"Concept 1: Filename Selection Patterns","text":""},{"location":"#filenamepath","title":"FileNamePath","text":"<p>We use <code>FileNamePath</code> class to represented the name selection pattern.</p> <p>The <code>FileNamePath</code> will select the files by it's pattern while ignore the file extension. The wildcard charcter is <code>{}</code> but it exclude the filename when separator(<code>.</code>) in it.</p> <p>For example, if theres exists files: <pre><code>sample.00.read.1.fq.gz\nsample.00.read.2.fq.gz\nsample.00.bwa.bam\nsample.00.bwa.sort.bam\nsample.00.bwa.sort.bqsr.bam\nsample.01.read.1.fq.gz\nsample.01.read.2.fq.gz\nsample.01.bwa.bam\nsample.01.04.read.2.fq.gz\nsample1.bwa.csv\nsample1.bowtie.csv\nsample1.bowtie.filter.csv\n</code></pre></p> FileNamePath listed FileNamePath <code>sample.{}</code> <code>sample.00</code> <code>sample.01</code> <code>sample.{}.bwa</code> <code>sample.00.bwa</code> <code>sample.01.bwa</code> <code>sample.{}.bwa.sort</code> <code>sample.00.bwa.sort</code> <code>sample.{}.read</code> <code>sample.00.read</code> <code>sample.01.read</code> <code>sample.{}.read.{}</code> <code>sample.00.read.1</code> <code>sample.00.read.2</code> <code>sample.01.read.1</code> <code>sample.01.read.2</code> <code>sample.00.read.{}</code> <code>sample.00.read.1</code> <code>sample.00.read.2</code> <code>sample{}</code> <code>sample.00.read</code> <code>sample.00.read</code> <code>sample1.{}</code> <code>sample1.bwa</code> <code>sample1.bowtie</code> <code>sample1.{}.csv</code> <code>sample1.bwa.csv</code> <code>sample1.bowtie.csv</code> <code>sample1.{method}.csv</code> <code>sample1.bwa.csv</code> <code>sample1.bowtie.csv</code> <p>Kind Hint, you may use <code>ln -s</code> to rename the file to match the pattern.</p>"},{"location":"#filenamepathlistfix","title":"FileNamePath.list(fix)","text":"<p>Next, if you want to select a group instead of executing tasks one by one, you can use the <code>fix</code> argument to indicate that the wildcard character <code>{}</code> should remain fixed and unexpanded. This feature is especially useful for tasks that require a list of files as input.</p> FileNamePath fix listed FileNamePath <code>sample.{}</code> <code>[-1]</code> <code>sample.{}</code> <code>sample.{}.bwa</code> <code>[-1]</code> <code>sample.{}.bwa</code> <code>sample.{}.read.{}</code> <code>[-1]</code> <code>sample.00.read.{}</code> <code>sample.01.read.{}</code> <code>sample.{}.read.{}</code> <code>[-2]</code> <code>sample.{}.read.1</code> <code>sample.{}.read.2</code> <code>sample.{}.read.{}</code> <code>[-1. -2]</code> <code>sample.{}.read.{}</code> <code>sample.{}.read.{}</code> <code>[]</code> <code>sample.00.read.1</code> <code>sample.00.read.2</code> <code>sample.01.read.1</code> <code>sample.01.read.2</code>"},{"location":"#concept-2-managing-workflow-steps-in-filenames","title":"Concept 2: Managing Workflow Steps in Filenames","text":"<p>In FileNameFlow, we adopt a straightforward approach to keep track of workflow steps. We save all the steps within the filename suffix, making it easy to understand what treatments have been applied to the data based on the filename.</p> Step Input Output File(we don't care) download <code>.</code> <code>sample.00.read</code> <code>sample.00.read.1.fq.gz</code>, <code>sample.00.read.2.fq.gz</code> bowtie2 <code>sample.00.read</code> <code>sample.00.read.bowtie_hg19</code> <code>sample.00.read.bowtie_hg19.sam</code> sortBam <code>sample.00.read.bowtie_hg19</code> <code>sample.00.read.bowtie_hg19.sort</code> <code>sample.00.read.bowtie_hg19.sort.bam</code> GatkBqsr <code>sample.00.read.bowtie_hg19.sort</code> <code>sample.00.read.bowtie_hg19.sort.bqsr</code> <code>sample.00.read.bowtie_hg19.sort.bqsr.bam</code> GatkHC <code>sample.00.read.bowtie_hg19.sort.bqsr</code> <code>sample.00.read.bowtie_hg19.sort.bqsr.hc</code> <code>sample.00.read.bowtie_hg19.sort.bqsr.hc.vcf.gz</code> <p>Furthermore, we incorporate parameters into the filenames to ensure that files generated with different parameters are kept separate. We use abbreviations when necessary to maintain readability.</p> Function Input Output bowtie2(index=\"hs37d5\") <code>sample.00.read</code> <code>sample.00.read.bowtie_hg19</code> bowtie2(index=\"hs38DH\") <code>sample.00.read</code> <code>sample.00.read.bowtie_hg38</code> <p>Our pipeline seamlessly handles suffix concatenation (<code>+</code>) or wildcard replacement (<code>apply</code>). Setting up pipelines is a breeze using <code>FileNamePath</code>, and you can define functions to handle each selected filename.</p> <p>Here's an example: <pre><code>from functools import partial\nfrom filenameflow import FileNamePath, FileNameTask\n\ndef bowtie2(input_name, index):\n    # The function are called two times\n    # where input_name =\n    # 1. sample.00.read.{}\n    # 2. sample.01.read.{}\n    print(input_name)\n    output_name = input_name + \".bowtie\" + index.replace(\"/\", \"_\")  # concat the suffix you want\n\n    fqs = sorted(input_name.list())  # use build-in list to list the current path e.g. sample.00.read.1, sample.00.read.2\n    os.system(f\"echo bowtie {index} {fqs[0]}.fq {fqs[1]}.fq -o {output_name}.sam\")  # FileNamePath works like str\n    return output_name  # return the result name for furthur task chaining\n\n# Using FileNamePath to kick start:\n# FileNamePath(\"sample.{}.read.{}\") &gt;&gt; partial(bowtie2, index=\"index/hg19\")\n# or using FileNameTask to start\n\"sample.{}.read.{}\" &gt;&gt; FileNameTask(partial(bowtie2, index=\"index/hg19\"), fix=[-1])\n</code></pre></p> <p>FileNameFlow simplifies complex data processing workflows by emphasizing functions for handling selected filenames, significantly reducing the need for extensive loops in your code.</p>"},{"location":"#concept-3-combining-functions-like-a-pipeline","title":"Concept 3: Combining Functions Like a Pipeline","text":"<p>In this concept, we combine the previously discussed concepts into our pipeline. For a complete code example, please refer to the <code>example.py</code> file in the GitHub repository.</p> <pre><code>def download(input_name):\n    # 1(indeed 0) -&gt; many\n    output_name = \"data/xxx.{}.read\"\n    if len(FileNamePath(output_name).list()):  # skip the step if file is downloaded\n        return output_name\n    # wget ...\n    return output_name\n\ndef bowtie2(input_name, index):\n    # 1 -&gt; 1\n    # input_name = \"data/xxx.{}.read\"\n    # output_name = \"data/xxx.{}.read.index_hs37d5\"\n    output_name = input_name + \".\" + index.replace(\"/\", \"_\")\n    if Path(output_name + \".sam\").exists():  # skip the step if file exists\n        return output_name\n    os.system(f\"bwa {index} {input_name}.1.fq {input_name}.2.fq -o {output_name}.sam\")\n    return output_name\n\ndef mergeCSV(input_name):\n    # many -&gt; 1\n    # input_name = \"data/xxx.{}.read.index_hs37d5.depth\"\n    # output_name = \"data/xxx_merge.read.index_hs37d5.depth\"\n    output_name = input_name.replace_wildcard(\"_merge\")\n    if Path(output_name + \".csv\").exists():\n        return output_name\n    files = input_name.list()\n    df = pd.concat(pd.read_csv(i + \".csv\") for i in files)\n    df.to_csv(output_name + \".csv\", index=False)\n    return output_name\n\ndef summaryCSV(input_name):\n    # 1 -&gt; 1\n    # doesn't change the suffix\n    df = pd.read_csv(i + \".csv\").groupby(\"chrom\").describe()\n    print(df)\n    return input_name\n\n# using &gt;&gt; to chain the tasks\nFileNamePath(\"\") &gt;&gt; download &gt;&gt; partial(bowtie2, index=\"index/hs37d5\") &gt;&gt; sortBam &gt;&gt; getLowReadDepthPos &gt;&gt; FileNameTask(mergeCSV, fix=[-1]) &gt;&gt; summaryCSV\n# Or using compose\nfrom filenameflow import compose\ncompose([\n    \".\",\n    download,                                # 0 to many\n    partial(bowtie2, index=\"index/hs37d5\"),  # 1 to 1\n    sortBam,                                 # 1 to 1\n    getLowReadDepthPos,                      # 1 to 1\n    FileNameTask(mergeCSV, fix=[-1]),        # many to 1\n    summaryCSV,                              # 1 to 1\n])\n</code></pre> <p>Our pipeline appears as a simple flow due to the list already being saved in the filename pattern, eliminating the need for explicit loops.</p>"},{"location":"#concept-4-shipping-your-pipeline-to-other-resources","title":"Concept 4: Shipping Your Pipeline to Other Resources","text":"<p>We provide two basic executors for your convenience:</p> <ul> <li>FileNameBaseExecutor (Default): Executes tasks one by one.</li> <li>DaskExecutor: Executes tasks using Dask, allowing you to leverage various computational resources. Refer to Dask for available resource options.</li> </ul> <pre><code>from filenameflow.executor import DaskExecutor\nfrom dask.distributed import LocalCluster\n\n# Set up a DaskExecutor with a LocalCluster\nexe = DaskExecutor(LocalCluster())\nFileNameTask.set_default_executor(exe)\n\n# Set the executor for a specific task\n\".\" &gt;&gt; download &gt;&gt; FileNameTask(partial(bowtie2, index=\"index/hs37d5\"), executor=exe)\n# Or set it globally\nFileNameTask.set_default_executor(exe)\n\".\" &gt;&gt; download &gt;&gt; partial(bowtie2, index=\"index/hs37d5\")\n</code></pre> <p>With FileNameFlow, you can effortlessly adapt the filename pipeline to different computation environments for efficient data processing.</p>"},{"location":"#conclusion","title":"Conclusion","text":"<ul> <li>Streamlined Data Science: Simplify file management and processing, perfect for bioinformatics tasks involving multiple file types.</li> <li>Simplicity: FileNameFlow streamlines pattern matching and grouping with minimal syntax, resembling string operations while offering wildcard support.</li> <li>Self-Descriptive Filenames: Each filename serves as a self-descriptive record of data processing steps, aiding in tracking and comprehension. It's like having automatic versioning as filenames adjust with pipeline changes.</li> <li>Flexible Filename Control: Beyond automatic wildcard listing and task execution, users can implement various rules. This includes customizing filename edits (like adding suffixes), renaming, system calls, and task skipping.</li> <li>Dask Resource Support: Harness the power of FileNameFlow's DaskExecutor to execute pipelines on various computational resources by given clusters (e.g. local, PBS, SLURM, ...).</li> <li>Python Integration: FileNameFlow seamlessly integrates with Python. You can use any Python packages you want.</li> </ul> <p>In summary, FileNameFlow empowers data scientists to efficiently manage, process, and collaborate on data, while simplifying intricate tasks. Its versatility, simplicity, and integration make it an invaluable tool in the data science toolkit.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/linnil1/FileNameFlow\n</code></pre>"},{"location":"#run","title":"Run","text":"<p>Run example</p> <pre><code>python example.py\n</code></pre>"},{"location":"#document","title":"Document","text":"<p>https://linnil1.github.io/FileNameFlow</p> <p>Error Class</p> <p>FileNamePath, a core path module of FileNameFlow.</p> <p>Handle the path pattern matching rule.</p>"},{"location":"#filenameflow.error.FileNameFlowAssert","title":"<code>FileNameFlowAssert</code>","text":"<p>             Bases: <code>FileNameFlowError</code></p> <p>Mostly this is internal error</p>"},{"location":"#filenameflow.error.FileNameFlowDataError","title":"<code>FileNameFlowDataError</code>","text":"<p>             Bases: <code>FileNameFlowError</code></p> <p>Error in exeution the pipeline</p>"},{"location":"#filenameflow.error.FileNameFlowError","title":"<code>FileNameFlowError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Basic exception for FileNameFlow module</p>"},{"location":"#filenameflow.path.FileNamePath","title":"<code>FileNamePath</code>","text":"<p>             Bases: <code>str</code></p> <p>FileNamePath is a specialized string class designed for managing filenames.</p> <p>Attributes:</p> Name Type Description <code>self</code> <code>str</code> <p>A string representing the current filename.</p> <code>template</code> <code>str</code> <p>The filename pattern serving as the basis for formatting filenames.</p> <code>args</code> <code>tuple[str, ...]</code> <p>A list containing positional arguments used for formatting <code>self</code> based on the <code>template</code>.</p> <code>kwargs</code> <code>Mapping[str, str]</code> <p>A dictionary containing keyword arguments used for formatting <code>self</code> based on the <code>template</code>.</p> <p>This class extends the functionality of Python's built-in <code>str</code> type.</p> <p>Wildcards: The FileNamePath class uses <code>{}</code> as wildcard characters and <code>*</code> as value in both args and kwargs.</p> Example <ul> <li> <p>With args:</p> <ul> <li>self: <code>test.sample.regression.lasso</code></li> <li>template: <code>test.{}.regression.{}</code></li> <li>args: [<code>\"sample\", \"lasso\"]</code></li> </ul> </li> <li> <p>With args containing a wildcard:</p> <ul> <li>self: <code>test.{}.regression.lasso</code></li> <li>template: <code>test.{}.regression.{}</code></li> <li>args: <code>[\"*\", \"lasso\"]</code></li> </ul> </li> <li> <p>With kwargs:</p> <ul> <li>self: <code>test.{}.regression.{type}</code></li> <li>template: <code>test.{}.regression.{type}</code></li> <li>args: <code>[\"*\"]</code></li> <li>kwargs: <code>{\"type\": \"*\"}</code></li> </ul> </li> </ul> Features <p>FileNamePath's primary feature is the ability to list files based on patterns.</p> <p><code>FileNamePath(\"test.{}.regression.lasso\").list()</code> will list all files starting with <code>test.*.regression.lasso</code> while ignoring the file extension.</p> <p>It also excludes files with separators inside wildcards, for instance:</p> <ul> <li><code>test.sample1.regression.lasso</code> (included in the listing)</li> <li><code>test.sample1.regression.lasso.txt</code> (excluded from the listing, the filename without suffix is same as previous one)</li> <li><code>test.sample1.regression.lasso.alpha10.txt</code> (excluded from the listing, the filename without suffix is same as previous one)</li> <li><code>test.sample2.regression.lasso</code> (included in the listing)</li> <li><code>test.sample_bad.sample1.regression.lasso</code> (excluded from the listing)</li> </ul> <p>After listing, the number of variables in <code>args</code> and <code>kwargs</code> is preserved, but their values change. For example, <code>test.sample1.regression.lasso</code> has <code>args</code> set to <code>[\"sample1\"]</code> instead of <code>[\"*\"]</code>.</p> <p>Another argument for the <code>list</code> method is <code>fix</code>, which allows you to fix specific variables from the listing. Example: <code>FileNamePath(\"test.{}.regression.{}\").list(fix=(0, ))</code> would yield:</p> <ul> <li><code>test.{}.regression.lasso</code> (with <code>args=[\"*\", \"lasso\"]</code>)</li> <li><code>test.{}.regression.elastic</code></li> <li><code>test.{}.regression.rigid</code></li> </ul> <p>Operations:</p> <ul> <li> <p><code>replace_wildcard()</code>: Replaces the \"{}\" wildcard with a specified string (e.g., \"_merge\").   Example: \"test.{}.regression\" becomes \"test_merge.regression\".</p> </li> <li> <p><code>+</code>: Concatenates FileNamePath objects.   Example: <code>FileNamePath(\"data.{}.regression\") + \".lasso\"</code>   results in <code>FileNamePath(\"data.{}.regression.lasso\")</code>.   Note that args and kwargs are preserved.</p> </li> <li> <p><code>apply()</code>: Applies arguments to the FileNamePath (similar to <code>.format()</code>).   Example: <code>FileNamePath(\"test.{}.regression.lasso\").apply(0, \"sample1\")</code>   results in <code>FileNamePath(\"test.merge.regression.lasso\")</code>.</p> </li> </ul>"},{"location":"#filenameflow.path.FileNamePath.args","title":"<code>args: tuple[str, ...] = tuple(path.args)</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.path.FileNamePath.kwargs","title":"<code>kwargs: Mapping[str, str] = dict(**path.kwargs)</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.path.FileNamePath.separator","title":"<code>separator = '.'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#filenameflow.path.FileNamePath.suffix_key","title":"<code>suffix_key = 'suffix_of_filename_for_filenamepath'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#filenameflow.path.FileNamePath.template","title":"<code>template: str = str(self)</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.path.FileNamePath.__add__","title":"<code>__add__(other: Any) -&gt; FileNamePath</code>","text":"<p>Concat the path.</p> <p>The function carefully handle the value in template, args, kwargs after concat.</p> Example <pre><code>FileNamePath(\"a.{}.c\") + \".d\"\n# result\nFileNamePath(\"a.{}.c.d\")\n</code></pre>"},{"location":"#filenameflow.path.FileNamePath.__init__","title":"<code>__init__(path: str)</code>","text":""},{"location":"#filenameflow.path.FileNamePath.__radd__","title":"<code>__radd__(other: Any) -&gt; FileNamePath</code>","text":"<p>Concat the path</p>"},{"location":"#filenameflow.path.FileNamePath.__rrshift__","title":"<code>__rrshift__(others: Any) -&gt; Any</code>","text":"<p>see compose()</p>"},{"location":"#filenameflow.path.FileNamePath.__rshift__","title":"<code>__rshift__(others: Any) -&gt; Any</code>","text":"<p>see compose()</p>"},{"location":"#filenameflow.path.FileNamePath.apply","title":"<code>apply(key: str | int, value: str) -&gt; FileNamePath</code>","text":"<p>Similar to .format(), but return new FileName Path that keep the template, args, kwargs</p> Example <pre><code>self: test.{}.regression.lasso\ntemplate: test.{}.regression.{}\nargs: [\"*\", \"lasso\"]\n\n# After .apply(0, \"sample2\")\nself: test.sample2.regression.{}\ntemplate: test.{}.regression.{}\nargs: [\"sample2\", \"*\"]\n</code></pre>"},{"location":"#filenameflow.path.FileNamePath.applys","title":"<code>applys(kv_pairs: Iterable[tuple[str | int, str]] = ()) -&gt; FileNamePath</code>","text":"<p>Similar to .apply, but allow apply multiple things</p>"},{"location":"#filenameflow.path.FileNamePath.commit","title":"<code>commit() -&gt; FileNamePath</code>","text":"<p>Substitue wildcards in the template by values from args and kwargs, except the value is wildcard charater '*'.</p> Example <pre><code>path: test.{}.regression.lasso\ntemplate: test.{}.regression.{type}\nargs: [\"*\"]\nkwargs: {type: \"lasso\"}\n\n# After .commit()\npath: test.{}.regression.lasso\ntemplate: test.{}.regression.lasso\nargs: [\"*\"]\nkwargs: {}\n</code></pre>"},{"location":"#filenameflow.path.FileNamePath.construct","title":"<code>construct(template: str, args: Iterable[str], kwargs: Mapping[str, str]) -&gt; FileNamePath</code>  <code>classmethod</code>","text":"<p>Construct a new FileNamePath via template, args, kwargs. The filename will be auto generated.</p>"},{"location":"#filenameflow.path.FileNamePath.get_args","title":"<code>get_args(key: int | str) -&gt; str</code>","text":"<p>Get arg, kwargs by key (int for positional arg, str for keyword kwargs)</p>"},{"location":"#filenameflow.path.FileNamePath.is_file","title":"<code>is_file() -&gt; bool</code>","text":"<p>Check if the FileNamePath represents a file (no wildcards in the path)</p>"},{"location":"#filenameflow.path.FileNamePath.list","title":"<code>list(fix: Iterable[str | int] = ()) -&gt; Iterable[FileNamePath]</code>","text":"<p>List files that match the current(self)'s name.</p> Example <pre><code>Path: \"cohort.{}.regression.{}\"\nfix: [1]\n# then Return:\n* `cohort.sample1.regression.{}`\n* `cohort.sample2.regression.{}`\n* `cohort.sample3.regression.{}`\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fix</code> <code>Iterable[str | int]</code> <p>The index of arg, kwargs that keep unlisted.      Note that the index is the wildcard's index on path, not the index in template.</p> <code>()</code>"},{"location":"#filenameflow.path.FileNamePath.list_args","title":"<code>list_args() -&gt; Mapping[str | int, str]</code>","text":"<p>List arg, kwargs in this FileNamePath, return a dict-like object</p>"},{"location":"#filenameflow.path.FileNamePath.overwrite","title":"<code>overwrite(key: int | str, value: str) -&gt; FileNamePath</code>","text":"<p>Force to change the value in args or kwargs. see .overwrites</p>"},{"location":"#filenameflow.path.FileNamePath.overwrites","title":"<code>overwrites(kv_pairs: Iterable[tuple[str | int, str]] = ()) -&gt; FileNamePath</code>","text":"<p>Force to change the value in args or kwargs.</p> Example <pre><code>Path: cohort.{}.regression.lasso\ntemplate: cohort.{}.regression.{}\nargs: [\"*\", \"lasso\"]\n# after .overwrite(`[(1, \"elastic\")]`)\nPath: cohort.{}.regression.elastic\ntemplate: cohort.{}.regression.{}\nargs: [\"*\", \"elastic\"]\n</code></pre>"},{"location":"#filenameflow.path.FileNamePath.parse","title":"<code>parse(filename: str) -&gt; tuple[str | None, tuple[str, ...], dict[str, str]]</code>","text":"<p>Parse the filename into arguments and keyword arguments according to self.template. The suffix is always removed. Returns template, args, kwargs.</p> <p>If the filename does not match the template, <code>(\"\", [], {})</code> is returned.</p> Example <pre><code>path = \"test.{}.regression.{type}\"\n# After .parse(\"test.sample1.regression.lasso.txt\")\ntemplate = \"test.{}.regression.{type}\"\nargs = [\"sample1\"]\nkwargs = {\"type\": \"lasso\"}\n</code></pre>"},{"location":"#filenameflow.path.FileNamePath.replace_wildcard","title":"<code>replace_wildcard(text: str = '_merge') -&gt; FileNamePath</code>","text":"<p>Replace the wildcard, similar to <code>.replace(\".{}\", \"_merge\")</code>. After replacment, the arg/kwargs will be removed.</p>"},{"location":"#filenameflow.path.FileNamePath.with_filename","title":"<code>with_filename(filename: str) -&gt; FileNamePath | None</code>","text":"<p>Create a new FileNamePath by filename and extract the args, kwargs by self.template.</p> <p>Returns:</p> Type Description <code>FileNamePath | None</code> <p>FileNamePath | None: A new FileNamePath object if successful, else None.</p>"},{"location":"#filenameflow.path.unique","title":"<code>unique(arr: Iterable[_T], key: Callable[[_T], Hashable]) -&gt; Iterable[_T]</code>","text":"<p>Return a unique sequence.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Iterable[_T]</code> <p>An sequence to be unique.</p> required <code>key</code> <code>Callable[[_T], Hashable]</code> <p>A function that returns the key of an element.</p> required <p>Returns:</p> Type Description <code>Iterable[_T]</code> <p>A unique sequence.</p>"},{"location":"#filenameflow.task.FileNameTaskFunc","title":"<code>FileNameTaskFunc = Callable[..., FileNameTaskOutput]</code>  <code>module-attribute</code>","text":""},{"location":"#filenameflow.task.FileNameTaskOutput","title":"<code>FileNameTaskOutput = None | str | FileNamePath</code>  <code>module-attribute</code>","text":""},{"location":"#filenameflow.task.FileNameTask","title":"<code>FileNameTask</code>","text":"<p>FileNameTask is the basic class that wraps your function to become a step in a pipeline. The execution can be triggered by the \"&gt;&gt;\" operator or using the compose function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>FileNameTaskFunc</code> <p>A function that defines the task to be performed on given filename (path).</p> <code>lambda : i</code> <code>fix</code> <code>Iterable[str | int]</code> <p>A list of integers (for positional arguments) or strings (for keyword arguments)         specifying which wildcards to ungroup.</p> <code>()</code> <code>executor</code> <code>FileNameBaseExecutor | None</code> <p>An optional custom executor to use for the task.</p> <code>None</code> <p>Example: * Usage 1:     Wrap the function to FileNameTask Object     <pre><code>@FileNameTask.wrapper(fix=[-1])\ndef func_manyto1(input_name, other_arg=\"1\"):\n    return input_name.replace_wildcard()\n\"data.{}.arg1\" &gt;&gt; func_manyto1\n\"data.{}.arg1\" &gt;&gt; func_manyto1(other_arg=\"2\")\n</code></pre></p> <ul> <li>Usage 2:     Execute the task by \"&gt;&gt;\"     <pre><code>def func_manyto1(input_name):\n    return input_name.replace_wildcard()\n\n\"data.{}.arg1\" &gt;&gt; FileNameTask(func_manyto1, fix=[-1])\n</code></pre></li> <li> <p>Usage 3:     Execute the task by compose     <pre><code>compose([\n    \"data.{}.arg1\",\n    func_manyto1,\n    FileNameTask(func_manyto1)(other_arg=\"1\"),  # or thisw\n    partial(func_manyto1, other_arg=\"2\"),  # or this\n])\n</code></pre></p> </li> <li> <p>Usage 4:     The output can be got by task.output     <pre><code>task = compose([\n    \"data.{}.arg1\",\n    func_manyto1,\n])\ncompose([\n    \"data.{}.arg2\",\n    partial(func_manyto1, other_arg=task.output),\n])\n</code></pre></p> </li> </ul>"},{"location":"#filenameflow.task.FileNameTask.executor","title":"<code>executor: FileNameBaseExecutor = func.executor</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.task.FileNameTask.fix","title":"<code>fix: Iterable[str | int] = fix</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.task.FileNameTask.func","title":"<code>func: FileNameTaskFunc = func.func</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.task.FileNameTask.input_path","title":"<code>input_path: FileNamePath | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.task.FileNameTask.output","title":"<code>output: FileNamePath</code>  <code>property</code>","text":"<p>Get the output path of the task</p>"},{"location":"#filenameflow.task.FileNameTask.output_path","title":"<code>output_path: FileNamePath | None = None</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.task.FileNameTask.__call__","title":"<code>__call__(*args: Any, **kwargs: Any) -&gt; FileNameTask</code>","text":"<p>Fill/Replace function's arguments</p>"},{"location":"#filenameflow.task.FileNameTask.__deepcopy__","title":"<code>__deepcopy__(memo: Any) -&gt; FileNameTask</code>","text":"<p>Deep copy this Object</p>"},{"location":"#filenameflow.task.FileNameTask.__init__","title":"<code>__init__(func: FileNameTaskFunc = lambda : i, fix: Iterable[str | int] = (), executor: FileNameBaseExecutor | None = None)</code>","text":""},{"location":"#filenameflow.task.FileNameTask.__repr__","title":"<code>__repr__() -&gt; str</code>","text":""},{"location":"#filenameflow.task.FileNameTask.__rrshift__","title":"<code>__rrshift__(others: Any) -&gt; Any</code>","text":"<p>see compose()</p>"},{"location":"#filenameflow.task.FileNameTask.__rshift__","title":"<code>__rshift__(others: Any) -&gt; Any</code>","text":"<p>see compose()</p>"},{"location":"#filenameflow.task.FileNameTask.run","title":"<code>run(path: FileNamePath) -&gt; FileNameTask</code>","text":"<p>Main function to excute the function</p>"},{"location":"#filenameflow.task.FileNameTask.set_default_executor","title":"<code>set_default_executor(executor: FileNameBaseExecutor) -&gt; None</code>  <code>classmethod</code>","text":"<p>Change default executor</p>"},{"location":"#filenameflow.task.FileNameTask.wrapper","title":"<code>wrapper(func: FileNameTaskFunc | None = None, /, **kwargs: Any) -&gt; FileNameTask | Callable[[FileNameTaskFunc], FileNameTask]</code>  <code>classmethod</code>","text":"<p>A decorator to create a FileNameTask() instance</p> <p>Example: <pre><code>from filenameflow import FileNameTask\n\n@FileNameTask.wrapper\ndef doSomething(input_name):\n    return input_name + \".test\"\n\n@FileNameTask.wrapper(fix=[-1])\ndef doSomething1(input_name):\n    return input_name.replace_wildcard()\n</code></pre></p>"},{"location":"#filenameflow.task.compose","title":"<code>compose(func_list: Iterable[FileNameTask | FileNamePath | FileNameTaskFunc | str]) -&gt; FileNameTask | FileNamePath</code>","text":"<p>Compose and execute a sequence of tasks in a pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>func_list</code> <code>Iterable[FileNameTask | FileNamePath | FileNameTaskFunc | str]</code> <p>An list containing a series of tasks such as FileNameTask, FileNamePath, Function, or filenames(str).</p> required <p>Returns:</p> Type Description <code>FileNameTask | FileNamePath</code> <p>FileNameTask or FileNamePath: The last task or path in the composed pipeline.</p> Example <pre><code>from filenameflow import compose\n\n# Execute the tasks based on previous output filenames.\n# Equivalent to task1 = \".\" &gt;&gt; doSomething &gt;&gt; doSomething2\ntask1 = compose([\n    \".\", doSomething, doSomething2\n])\n\n# Assert if the output of task1 is equal to the given filename.\n# Equivalent to task2 = task1 &gt;&gt; \"expected_result_path\"\ntask2 = compose([\n    task1 , \"expected_result_path\"\n])\n</code></pre>"},{"location":"#filenameflow.executor.DaskExecutor","title":"<code>DaskExecutor</code>","text":"<p>             Bases: <code>FileNameBaseExecutor</code></p> <p>Run the filenameflow under Dask.</p> <p>Dask is convenient resource manager for distributed computing.</p> <p>Using this Executor by <pre><code>FileNameTask.set_default_executor(DaskExecutor())\n</code></pre></p>"},{"location":"#filenameflow.executor.DaskExecutor.client","title":"<code>client = Client(cluster)</code>  <code>instance-attribute</code>","text":""},{"location":"#filenameflow.executor.DaskExecutor.__init__","title":"<code>__init__(cluster: Any = None)</code>","text":""},{"location":"#filenameflow.executor.DaskExecutor.run_task","title":"<code>run_task(func: Callable[..., FileNameTaskOutput], names: Iterable[FileNamePath]) -&gt; Iterable[FileNamePath | str]</code>","text":"<p>Using client.submit to run all tasks</p>"},{"location":"#filenameflow.executor.FileNameBaseExecutor","title":"<code>FileNameBaseExecutor</code>","text":"<p>The FileNameExecutor is a base class for implementing custom task executors within the FileNameFlow framework.</p>"},{"location":"#filenameflow.executor.FileNameBaseExecutor.post_task","title":"<code>post_task(path: FileNamePath) -&gt; FileNamePath</code>","text":"<p>This method is called after executing tasks. It receives the output FileNamePath and returns the modified FileNamePath.</p>"},{"location":"#filenameflow.executor.FileNameBaseExecutor.pre_task","title":"<code>pre_task(path: FileNamePath) -&gt; FileNamePath</code>","text":"<p>This method is called before executing a task. It receives the input FileNamePath and returns the modified FileNamePath.</p>"},{"location":"#filenameflow.executor.FileNameBaseExecutor.run_task","title":"<code>run_task(func: FileNameTaskFunc, paths: Iterable[FileNamePath]) -&gt; Iterable[FileNameTaskOutput]</code>","text":"<p>This method is responsible for running the task for each filename with FileNamePath class. It yields the results of the task execution.</p>"}]}